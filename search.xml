<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端工程化-模块化</title>
      <link href="/fe_engine_02/"/>
      <url>/fe_engine_02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>上一篇文章《前端工程化-序言》中提到”项目复杂度”的问题。</p><p>文章开头，其实可以先思考一下，项目复杂度为什么会提升？</p><ul><li>不好的开发习惯，没有规范？</li><li>单文件、巨石代码？</li><li>命令式编程，毫无章法可言？</li></ul><p>结论是肯定的，大部分场景的项目复杂度的提升都离不开以上的三种原因，当然也有别的原因，我这里暂时先列举这三种主要的。</p><p>所以，前端开发的思想以及技术要革新，模块化技术也随之更替演变。</p><h2 id="模块化之function-猿猴模式"><a href="#模块化之function-猿猴模式" class="headerlink" title="模块化之function-猿猴模式"></a>模块化之<code>function</code>-猿猴模式</h2><p>借助函数实现模块化，最终还是暴露在 <code>window</code> 上，内部封闭了若干常量。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">getEnvUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        qa<span class="token operator">:</span> <span class="token string">'test.xxx'</span><span class="token punctuation">,</span>        pre<span class="token operator">:</span> <span class="token string">'pre.xxx'</span><span class="token punctuation">,</span>        prod<span class="token operator">:</span> <span class="token string">'prod.xxx'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">getGatwayByEnv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        qa<span class="token operator">:</span> <span class="token string">'test.gatway.xxx'</span><span class="token punctuation">,</span>        pre<span class="token operator">:</span> <span class="token string">'pre.gatway.xxx'</span><span class="token punctuation">,</span>        prod<span class="token operator">:</span> <span class="token string">'prod.gatway.xxx'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> qaUrl <span class="token operator">=</span> <span class="token function">getEnvUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>qa<span class="token punctuation">;</span></code></pre><ul><li>缺点<ul><li>容易明名冲突</li><li>模块函数众多，且毫无关联</li></ul></li></ul><p>改进：<br>    - 可以作函数聚合、函数收敛</p><h2 id="模块化之namespace-原始人"><a href="#模块化之namespace-原始人" class="headerlink" title="模块化之namespace-原始人"></a>模块化之<code>namespace</code>-原始人</h2><p>使用全局变量聚合所有函数模块以及常量模块；</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">var</span> __module__ <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    __vars<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        env<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'qa'</span><span class="token punctuation">,</span> <span class="token string">'pre'</span><span class="token punctuation">,</span> <span class="token string">'prod'</span><span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span class="token comment">// 严格意义上等同于 window.__module__</span></code></pre><ul><li>优点：<ul><li>避免了命名冲突</li></ul></li><li>缺点：<ul><li>外部容易修改</li></ul></li></ul><p><strong>改进</strong>： <code>Object.freeze</code> 冻结对象属性。</p><h2 id="模块化之IIFE-山顶洞人"><a href="#模块化之IIFE-山顶洞人" class="headerlink" title="模块化之IIFE-山顶洞人"></a>模块化之<code>IIFE</code>-山顶洞人</h2><p>闭包实现模块化，保证内部的变量私有化，只暴露访问函数，外部无法改变内部私有化变量；</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token function-variable function">getX</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> x<span class="token punctuation">;</span>    root<span class="token punctuation">.</span>__XModule <span class="token operator">=</span> <span class="token punctuation">&#123;</span>         getX    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>root<span class="token punctuation">,</span> xModule<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    root<span class="token punctuation">.</span>__YModule <span class="token operator">=</span> xModule<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> window<span class="token punctuation">.</span>__XModule<span class="token punctuation">)</span></code></pre><ul><li>好处<ul><li>解决了私有化变量的问题</li><li>解决了模块之间互相引用的问题</li></ul></li></ul><p>籍此，早起模块化的实现方案就此诞生了，但是按照早期的方案而言，一个项目中如果存在若干个模块就势必会出现若干个 <code>script</code> 标签。</p><p>由此导致的后果就是： 拖慢应用加载速度，牺牲用户的体验，流量流失。</p><hr><p>在介绍现代模块化的前面，这里先解释下，模块化到底是什么？</p><blockquote><p>模块化是 <strong>规范</strong>，不是 <strong>实现</strong>。</p></blockquote><ul><li>Node<ul><li>commonjs</li><li>esmodule<ul><li>mjs</li></ul></li></ul></li><li>Browser<ul><li>amd</li><li>cmd</li><li>esmodule</li></ul></li><li>Node &amp; Browser<ul><li>umd</li></ul></li></ul><p>本篇文章暂时不具体介绍 <code>amd</code>、<code>cmd</code> 规范，因为目前基本不再使用了。</p><h3 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h3><p><code>CommonJs</code>规范，本身是基于 <code>IIFE</code> 机制实现的。</p><p>那么，可以思考：<code>require</code>、<code>module</code> 等为什么可以直接使用？</p><blockquote><p>模块加载时，自动注入。</p></blockquote><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">Module</span><span class="token punctuation">(</span><span class="token keyword">require</span><span class="token punctuation">,</span> module<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function-variable function">require</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token number">0</span><span class="token punctuation">,</span> module <span class="token operator">=</span> <span class="token punctuation">&#123;</span> exports<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>下面是 <code>CommonJs</code> 模块加载原理。</p><p><img src="https://to-out-use.oss-cn-hangzhou.aliyuncs.com/common/lNqgxU.png" loading="lazy"><br>图片来源于：<a href="https://javascript.ruanyifeng.com/nodejs/module.html#toc14">https://javascript.ruanyifeng.com/nodejs/module.html#toc14</a></p><ul><li>特点<ul><li>同步加载</li><li>运行时加载，会先加载一遍全模块，再缓存</li><li>模块输出是值拷贝<ul><li>注意：是浅拷贝</li></ul></li></ul></li></ul><h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h3><p>规范参考：<a href="https://michaelcurrin.github.io/dev-cheatsheets/cheatsheets/javascript/general/modules/es-modules.html">https://michaelcurrin.github.io/dev-cheatsheets/cheatsheets/javascript/general/modules/es-modules.html</a></p><ul><li>特点<ul><li>同步&#x2F;异步加载</li><li>编译时加载</li><li>模块输出是值引用</li></ul></li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>文章结束了，请思考一个问题：</p><blockquote><p>模块化最终解决了什么问题？</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://javascript.ruanyifeng.com/nodejs/module.html">CommonJs规范</a></li><li><a href="https://michaelcurrin.github.io/dev-cheatsheets/cheatsheets/javascript/general/modules/es-modules.html">ES Module规范</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化-序言</title>
      <link href="/fe_engine_01/"/>
      <url>/fe_engine_01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>关于<strong>前端工程化</strong>的字眼现在已经”横尸”各大静态博文平台了，包含一部分专业领域的书籍中。但是这些内容中，或者说”快餐知识”中似乎都有一个通病，那就是没有去阐述几个概念：</p><ul><li>前端工程化出现的背景是什么？</li><li>前端工程化的目的是什么？</li><li>什么是前端工程化呢？</li></ul><p>虽然实践固然重要，但是我还是想单独抽出这么一篇内容作一个总结性的阐述。所谓：”知其然，同需知其所以然”。</p><span id="more"></span><h2 id="前端工程化的背景"><a href="#前端工程化的背景" class="headerlink" title="前端工程化的背景"></a>前端工程化的背景</h2><p>谈及背景，我们总会联想到现状，当然这个”现状”目前就是指代”过去的现状”了。</p><p>我觉得就过去而言，我们可以首先来聊一聊过去到现在的开发模式演变：</p><ul><li>前后端不分离 <code>JSP</code> 、<code>ejs</code> 、<code>jade</code> ……</li><li>前后端分离：<code>Java</code> 主张的 <code>MVC</code> 时代，使 <code>UI</code> 负担脱离后端研发</li><li>模块化开发，<code>SPA</code> 入世：随着 <code>ajax</code> 技术的出现和早期 <code>CDN</code> 的推崇，前端迎来了 <code>SPA</code> 时代。同时也出现了 <code>jQuery</code> 般的 <code>IIFE</code> 模块化方案</li><li>模块化开发+ <code>MVVM</code> ：<code>React</code> 、<code>Vue</code> 、<code>Svlete</code> 、<code>solid</code>、<code>webpack</code>、<code>vite</code>等 的出现。</li></ul><p>随着这一系列的开发模式的演变，以及互联网 <code>web</code> 开发业务的日益复杂和多元化。各种巨石应用的治理、企业历史技术负债的优化，前端开发效率的提升，开发上线全流程的观测等等一系列的问题都是前端工程化出现的背景。</p><h2 id="前端工程化的目的"><a href="#前端工程化的目的" class="headerlink" title="前端工程化的目的"></a>前端工程化的目的</h2><ul><li>开发效率<ul><li>模版开发</li><li><code>JSX</code></li><li><code>less</code> 、<code>sass</code></li><li>…</li></ul></li><li>开发规范<ul><li><code>eslint</code></li><li><code>prettier</code></li><li><code>husky</code></li><li><code>commit cz</code></li><li>…</li></ul></li><li>性能<ul><li>构建速度</li><li>访问性能</li><li>单测性能</li><li>兼容性</li><li>监控、埋点</li><li>…</li></ul></li><li>持续集成<ul><li><code>CI/CD</code></li><li><code>jekins</code></li><li><code>k8s</code></li><li><code>docker</code></li><li>…</li></ul></li></ul><p>大部分的工程化手段基本都集中在解决上述问题，这也是前端工程化的目的。</p><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><p>上面讲述了这么多，都始终没解释，什么是前端工程化？</p><p>先上一波知乎大牛的解释：</p><ul><li><a href="https://www.zhihu.com/question/433854153">https://www.zhihu.com/question/433854153</a></li><li><a href="https://www.zhihu.com/question/24558375">https://www.zhihu.com/question/24558375</a></li></ul><p>搜索引擎上关于 <strong>前端工程化</strong> 的介绍还蛮多，其实这里我更赞同 <code>程墨Morgan</code> 的回答：</p><p><img src="https://to-out-use.oss-cn-hangzhou.aliyuncs.com/common/PTTHIn.png" loading="lazy"></p><p>的确是这样，比如其他的回答中，介绍各种流程中的”手段”，那这些手段又何尝不是解决这些软件开发中所碰到的问题呢，不论什么”端”，其实都将就一个字<strong>通</strong>。</p><h2 id="文末彩蛋"><a href="#文末彩蛋" class="headerlink" title="文末彩蛋"></a>文末彩蛋</h2><p>鉴于近期的 <code>ChatGPT</code> 的火热，部分人的内心或许会有些许动摇，但是还是那句话：<strong>机器取代人的时代还早</strong>。</p><p>高分观点：</p><p><img src="https://to-out-use.oss-cn-hangzhou.aliyuncs.com/common/WWLnd5.png" loading="lazy"></p><p><img src="https://to-out-use.oss-cn-hangzhou.aliyuncs.com/common/DtBaNy.png" loading="lazy"></p><p>大胆的去做吧，<code>just try</code>，相比于 <strong>程序</strong> 而言，<strong>程序员</strong> 才是一笔宝贵的财富。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/7112689303146201101">前端工程化概念介绍</a></li><li><a href="https://www.zhihu.com/question/24558375">解释前端工程化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>改变</title>
      <link href="/mind/"/>
      <url>/mind/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>距离 <code>25岁</code> 还剩接近半年时间，慢慢的想明白了一些事情。最大的可能是心境和情绪控制的改变吧，其次是对于生活的态度。</p><p>就在前天，我把我工作账号的签名(<code>bio</code>) 改成了 <code>Stay Foolish</code>，引用自<strong>乔布斯</strong> 的金句：<code>Stay Hungry, Stay Foolish</code>。「保持野心，保持痴心。」</p><p>约莫前几个月的时间中，我几乎度日如年，太多的精神内耗充斥着我的内心，乃至身体各处，虽然白日里一副嬉皮笑脸，但是回到家，才会表现出满满的疲惫感。这种疲惫感，来自工作，来自生活，来自自己。可能是想多了吧，想多了就容易这样。</p><p>不过，后来我想通了，那些虚的，与自己无关的事，不必太操心，有些东西不必太在意，有些话，也不用太在意，做好自己。</p><p>报复性的放松之后才发现，浪费了很多时间，慢慢退化了很多习惯，所以就有了这篇文章的标题”改变”。没错，就是改变，改变为人处事的态度：</p><ul><li>没必要立刻回复的消息，就暂时搁置；</li><li>没有价值的话，没必要放心上太久；</li><li>坚持，就要贯彻始终；</li></ul><p>坚持做对而正确的事情。</p><p>依旧记的一个朋友给我的谏言，<strong>不要给你自己设上限</strong>，不去做怎么知道呢？</p><p>反思过去的学习工作方式，一个不好的点就是，没有沉淀，思维没有衔接，想法没有真实的落地。思维老是会产生疲惫感，总是喜欢看，不喜欢去做。这是不是大家的通病呢？</p><p>其实我也蛮好奇的，准备亲身的去探索一下，”舒适区和紧张区的边界”。</p><p>一直在说对代码感兴趣，对程序感兴趣，确实感兴趣，但是确实懒得写，这是实话，我觉得有必要<strong>改变</strong>一下了。思考了下，没有动力的原因：</p><ul><li>不围绕工作；</li><li>不能产生实际的效益；</li><li>没有明确的方向感；</li></ul><p>最近试了试一个思维脑图的工具：<code>GitMind</code>，顺手冲了个年费会员，个人感觉还是蛮不错的，比 <code>Xmind</code> 好用且便宜。有人可能会好奇，买这个干啥呢？</p><p>正好在 <code>montagejs</code> 里复刻浩哥的 <code>react-launcher</code>，起名 <code>PanGu</code>，写了一半的时候，觉得该理一理， <code>PanGu</code> 的定位是什么？需要解决什么问题？提供什么能力，于是我画了画，思路一下就清晰了：</p><p><img src="https://to-out-use.oss-cn-hangzhou.aliyuncs.com/common/PanGu.png" loading="lazy"></p><p>确实是这样，想必，屏幕前的你，跟我一样的感觉，第一视觉下的感觉都是，至少思维和方向清晰了不少。</p><p>所以后面对于学习的改变应该是：</p><ul><li>聚合碎片化的知识点；</li><li>系统化；</li><li>脑图化，让大脑清晰自己在做什么；</li></ul><p>不知道这样一篇文章对于屏幕前的你收获有多少呢？</p><p>我觉得至少应该会有些情感或者精神共鸣吧，因为，人都是有共性的。</p><p>最后，一心向阳，做好自己，最重要的事是先改变自己。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重温 HTTP 缓存</title>
      <link href="/review-http-cache/"/>
      <url>/review-http-cache/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><blockquote><p>(: 因为一手文章在掘金，只换了 <code>gif</code> ，剩下的原图有水印，懒得换了，gif 有些模糊，自行脑补。</p></blockquote><p>蓦然回首，那“缓存”却在灯火阑珊处～</p><h3 id="Situation（情景）"><a href="#Situation（情景）" class="headerlink" title="Situation（情景）"></a>Situation（情景）</h3><p>作为日常的知识复习，重温一下浏览器缓存。</p><p>知识不止于眼前的文字，更在当下的实操。</p><h3 id="Task（任务）"><a href="#Task（任务）" class="headerlink" title="Task（任务）"></a>Task（任务）</h3><ul><li>通过查阅权威资料整理关键知识点</li><li>通过实操，重温缓存场景</li></ul><span id="more"></span><h3 id="Action（动作）"><a href="#Action（动作）" class="headerlink" title="Action（动作）"></a>Action（动作）</h3><p>我们可以先来聊一个概念，就是一个东西的出现必然是有意义的。为什么要缓存？</p><blockquote><p>简单讲，节省不必要的流量开支，提升客户端访问速度。</p></blockquote><p>更宏观意义上来讲：</p><blockquote><p>蝴蝶效应：大量网络请求会消耗资源，产生热量，导致全球变暖。</p></blockquote><p>举个例子：当 <code>Client</code> 每次向 <code>Server</code> 请求资源，相同的资源只有首次加载会耗费流量，后面统一从本地缓存中拿。</p><hr><p>开始之前先介绍一个概念：<strong>新鲜度（Freshness）</strong></p><p>摘录自：<a href="https://httpwg.org/specs/rfc7234.html#expiration.model">HTTP 规范</a></p><blockquote><p>A fresh response is one whose age has not yet exceeded its freshness lifetime. Conversely, a stale response is one where it has.</p><p>新鲜响应是指其年龄尚未超过其新鲜期的响应。反之，陈旧的响应是指它已经超过了。</p></blockquote><blockquote><p>A response’s freshness lifetime is the length of time between its generation by the origin server and its expiration time. An explicit expiration time is the time at which the origin server intends that a stored response can no longer be used by a cache without further validation, whereas a heuristic expiration time is assigned by a cache when no explicit expiration time is available.</p><p>响应的保鲜期是指从源服务器生成到过期时间之间的时间长度。明确的过期时间是指源服务器打算让缓存在没有进一步验证的情况下不再使用存储的响应的时间，而启发式过期时间是由缓存在没有明确过期时间的情况下指定的。</p></blockquote><p><strong>确定新鲜度的主要机制是源服务器使用<a href="https://httpwg.org/specs/rfc7234.html#header.expires">Expires</a>标头字段（<a href="https://httpwg.org/specs/rfc7234.html#header.expires" title="过期">第 5.3 节</a>）或 max-age 响应指令（<a href="https://httpwg.org/specs/rfc7234.html#cache-response-directive.max-age" title="最大年龄">第 5.2.2.8 节</a>）提供未来的明确到期时间。</strong></p><p>公式：<code>response_is_fresh = (freshness_lifetime &gt; current_age)</code></p><ul><li><p><code>freshness_lifetime</code></p><ul><li>如果缓存是共享的并且存在 s-maxage 响应指令（<a href="https://httpwg.org/specs/rfc7234.html#cache-response-directive.s-maxage" title="s-maxage">第 5.2.2.9 节</a>），则使用它的值，或者</li><li>如果存在 max-age 响应指令（<a href="https://httpwg.org/specs/rfc7234.html#cache-response-directive.max-age" title="最大年龄">第 5.2.2.8 节</a>），请使用它的值，或者</li><li>如果存在<a href="https://httpwg.org/specs/rfc7234.html#header.expires">Expires</a>响应头字段（<a href="https://httpwg.org/specs/rfc7234.html#header.expires" title="过期">第 5.3 节</a>），则使用其值减去<a href="https://httpwg.org/specs/rfc7231.html#header.date">Date</a>响应头字段的值，或者</li><li>否则，响应中不存在明确的到期时间。启发式的新鲜度生命周期可能适用；请参阅<a href="https://httpwg.org/specs/rfc7234.html#heuristic.freshness" title="计算启发式新鲜度">第 4.2.2 节</a>。</li></ul></li><li><p><code>current_age</code></p><ul><li>由于规范内容过多，并非本文的重点，这里不再做赘述，详细可查看：<a href="https://httpwg.org/specs/rfc7234.html#age.calculations">传送门</a></li></ul></li></ul><p>总结一句话：通过 <code>Cache-Control</code> 和 <code>Expires</code> ，原始服务器可以对资源定义其保质期。在保质期之内，缓存就认为该资源是新鲜的，可以直接传回给客户端，如果过期那么就需要进行再验证。</p><h4 id="HTTP-缓存策略："><a href="#HTTP-缓存策略：" class="headerlink" title="HTTP 缓存策略："></a>HTTP 缓存策略：</h4><ul><li>强缓存（<code>Response Header</code> 中的 <code>Expries</code> 和 <code>Cache-Control</code> 头）</li><li>协商缓存（<code>Res &amp; Req Header</code> 中的  <code>Last-Modify/If-Modify-Since</code> 和 <code>Etag/If-None-Match</code>）</li></ul><p>下面展开讲一讲</p><p><strong>Expries</strong>（<a href="https://www.rfc-editor.org/rfc/rfc822#section-5.1">需要固定格式的绝对日期</a>）</p><p>表示缓存过期的时间，相对于主机而言的绝对时间。</p><p>先简单用 <code>nest</code> 随便搭建个静态资源服务器，并设置 <code>Expires</code> 头：</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript">app<span class="token punctuation">.</span><span class="token function">useStaticAssets</span><span class="token punctuation">(</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'..'</span><span class="token punctuation">,</span> <span class="token string">'public'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">setHeaders</span><span class="token operator">:</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span>      <span class="token string">'Expires'</span><span class="token punctuation">,</span>      <span class="token function">dayjs</span><span class="token punctuation">(</span><span class="token string">'2022-08-19 13:00:15'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token string">'seconds'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Cache-Control'</span><span class="token punctuation">,</span> <span class="token string">'private'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Date'</span><span class="token punctuation">,</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  lastModified<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  etag<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>来个动画</p><p><img src="https://to-out-use.oss-cn-hangzhou.aliyuncs.com/common/Kapture%202022-08-19%20at%2012.46.04.gif" alt="Kapture 2022-08-19 at 12.46.04.gif" loading="lazy"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c55b3a25bf948359e693274c3fcc440~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></p><p>首次请求时，浏览器进行了数据缓存，再次请求就不再向服务器发送请求，而是直接从 <code>disk cache</code> 中拿了。</p><p><strong>Cache-Control</strong></p><p>下面是头可选的几个值：</p><pre class="language-bash" data-language="bash"><code class="language-bash">Cache-Control: no-store, no-cache, max-age<span class="token operator">=</span><span class="token number">0</span>, must-revalidate, proxy-revalidate</code></pre><p>先在静态资源服务器的 <code>Response</code> 上塞个 <code>Cache-Control</code> 头：</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript">app<span class="token punctuation">.</span><span class="token function">useStaticAssets</span><span class="token punctuation">(</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'..'</span><span class="token punctuation">,</span> <span class="token string">'public'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">setHeaders</span><span class="token operator">:</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// res.setHeader(</span>    <span class="token comment">//   'Expires',</span>    <span class="token comment">//   dayjs('2022-08-19 13:00:15').add(15, 'seconds').toDate(),</span>    <span class="token comment">// );</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Cache-Control'</span><span class="token punctuation">,</span> <span class="token string">'max-age=3000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Date'</span><span class="token punctuation">,</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  lastModified<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  etag<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>依旧再看动画：</p><p><img src="https://to-out-use.oss-cn-hangzhou.aliyuncs.com/common/Kapture%202022-08-19%20at%2013.01.30.gif" alt="Kapture 2022-08-19 at 13.01.30.gif" loading="lazy"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9579dbedc0544b619aaf06d5d22760d0~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></p><p><code>max-age=3000</code> 的意思就是 <code>3000</code> 秒后过期。这个 <code>3000</code> 秒是相对于 <code>Response</code> 的 <code>Date</code> 头而言的。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71722c5873fc419f8f771a5347936cfb~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></p><p>为了说明根本机时间是无关的，我截图了最新一次请求和我本机时间的截图拼接。</p><p>那么如果两个头都存在呢？会做何种决策？实践的结果可能并不能说服我们，一样的思路，先翻规范，后实践证实。</p><blockquote><p>If a response includes a <a href="https://httpwg.org/specs/rfc7234.html#header.cache-control">Cache-Control</a> field with the max-age directive (<a href="https://httpwg.org/specs/rfc7234.html#cache-response-directive.max-age" title="max-age">Section 5.2.2.8</a>), a recipient <em>MUST</em> ignore the Expires field. Likewise, if a response includes the s-maxage directive (<a href="https://httpwg.org/specs/rfc7234.html#cache-response-directive.s-maxage" title="s-maxage">Section 5.2.2.9</a>), a shared cache recipient <em>MUST</em> ignore the Expires field. In both these cases, the value in Expires is only intended for recipients that have not yet implemented the Cache-Control field.</p></blockquote><blockquote><p>如果一个响应包括一个带有max-age指令的<a href="https://httpwg.org/specs/rfc7234.html#header.cache-control">Cache-Control</a>字段（<a href="https://httpwg.org/specs/rfc7234.html#cache-response-directive.max-age" title="max-age">第5.2.2.8节</a>），接收者<em>必须</em>忽略 Expires 字段。同样，如果一个响应包括 s-maxage 指令（<a href="https://httpwg.org/specs/rfc7234.html#cache-response-directive.s-maxage" title="s-maxage">第5.2.2.9节</a>），共享缓存接收者<em>必须</em>忽略 Expires 字段。在这两种情况下，Expires 中的值只针对还没有实现 Cache-Control 字段的接收者。</p></blockquote><p><strong>规范结论：如果同时存在，那么以 <code>max-age</code> 为准。</strong></p><p>下面，我们同时设置这两个头：</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript">app<span class="token punctuation">.</span><span class="token function">useStaticAssets</span><span class="token punctuation">(</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'..'</span><span class="token punctuation">,</span> <span class="token string">'public'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">setHeaders</span><span class="token operator">:</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span>      <span class="token string">'Expires'</span><span class="token punctuation">,</span>      <span class="token function">dayjs</span><span class="token punctuation">(</span><span class="token string">'2022-08-20 13:00:15'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token string">'seconds'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Cache-Control'</span><span class="token punctuation">,</span> <span class="token string">'public,max-age=0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Date'</span><span class="token punctuation">,</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  lastModified<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  etag<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>接着看动画：</p><p><img src="https://to-out-use.oss-cn-hangzhou.aliyuncs.com/common/Kapture%202022-08-19%20at%2020.48.32.gif" alt="Kapture 2022-08-19 at 20.48.32.gif" loading="lazy"></p><p>可以看到，每次请求都是原始的 <code>4.8m</code>。小提示：<code>max-age=0</code> 等同于 <code>no-cache</code>。</p><p><strong>小 Tip：每次请求如何要求浏览器不拿内存呢？前提是不使用 <code>Response Header</code> 做文章</strong></p><ul><li><ol><li>在 <code>Dev Tools</code> 里开启 <code>Disable cache</code></li></ol><p>  <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dfc4a3d0b7c4012b44da7975ff69468~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></p></li><li><ol start="2"><li>借助 <code>Chrome</code> 插件， <code>Requesty</code> 来进行手动设置</li></ol></li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceda93029f9140a9b3519ad6cf8ef53c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></p><p>这里可以再提一个概念：重新加载和强制重新加载，见<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#reload_and_force_reload">MDN</a></p><p>重新加载的实现方式：据 <code>MDN</code> 描述：</p><blockquote><p>For recovering from window corruption or updating to the latest version of the resource, browsers provide a reload function for users.</p></blockquote><blockquote><p>That behavior is also defined in the <a href="https://fetch.spec.whatwg.org/#http-network-or-cache-fetch">Fetch</a> standard and can be reproduced in JavaScript by calling <code>fetch()</code> with the cache mode set to <code>no-cache</code> (note that <code>reload</code> is not the right mode for this case):</p></blockquote><p>上文借助 <code>chrome</code> 插件就是用了后者去实现重新加载的。</p><p>强制重新加载的实现方式：</p><ul><li><p>开启 <code>Disable cache</code></p></li><li><p>在浏览器中操作</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ba7298219994c6e887c70f5453127b6~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></p></li></ul><hr><p>接着上面的内容，我们来继续扩展讲讲剩下的几个值，应用到 <code>Cache-Control</code> 上有什么效果。这里只列举常用的。</p><ul><li><p><code>private</code> &#x2F; <code>public</code></p><ul><li><code>private</code> 代表私有缓存，例如近用户浏览器本地缓存等；</li><li><code>public</code> 代表共享缓存；<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bc7a964ea93455b9e313fbdd27fa6f9~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"><br>—- 来自<a href="https://stackoverflow.com/questions/3492319/private-vs-public-in-cache-control">Stackoverflow</a></li></ul></li><li><p><code>no-cache</code></p><ul><li>要求缓存重新验证与源服务器的每个请求。</li></ul></li><li><p><code>no-store</code></p><ul><li>禁止缓存</li></ul></li></ul><p>到这里，强缓存就结束了。</p><p>那么思考一个问题，缓存失效了，它还能用吗？我想“续命”再用怎么办？跟服务端 <code>token</code> 续命相仿。带着这个问题，我们开始协商缓存的介绍。</p><hr><p>同样的形式，跟上文一样，我们开始从 <code>http 1.0</code> 的标准到 <code>http 1.1</code>。</p><p><strong><code>Last-Modified</code> &amp; <code>If-Modified-Since</code></strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">Last-Modified: <span class="token number">2022</span>-08-19 <span class="token number">22</span>:00:00Cache-Control: max-age<span class="token operator">=</span><span class="token number">20</span></code></pre><p>当请求资源后，浏览器收到这个相应头后开始缓存，并且标注“这个资源”最后更改的时间是：<code>2022-08-19 22:00:00</code>，并且在 <code>20</code> 秒后过期。</p><p>等这 <code>20s</code>过期后，浏览器带着客户端的 <code>If-Modified-Since</code> 头说：老弟，我帮你问问，服务器的资源有没有变更过，问完之后，发现就没变过，返回 <code>304</code>，继续从缓存里拿。</p><p>如果是新的，那么就执行下类似 <code>no-cache</code> 的操作，给到客户端最新的资源。</p><p>我们开始操作静态资源服务器的设置：</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript">app<span class="token punctuation">.</span><span class="token function">useStaticAssets</span><span class="token punctuation">(</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'..'</span><span class="token punctuation">,</span> <span class="token string">'public'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">setHeaders</span><span class="token operator">:</span> <span class="token punctuation">(</span>res<span class="token punctuation">,</span> path<span class="token punctuation">,</span> stat<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// res.setHeader(</span>    <span class="token comment">//   'Expires',</span>    <span class="token comment">//   dayjs('2022-08-20 13:00:15').add(15, 'seconds').toDate(),</span>    <span class="token comment">// );</span>    <span class="token comment">// res.setHeader('Cache-Control', 'private');</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Last-Modified'</span><span class="token punctuation">,</span> <span class="token function">dayjs</span><span class="token punctuation">(</span><span class="token string">'2022-08-19 19:38:15'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Date'</span><span class="token punctuation">,</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// lastModified: false,</span>  etag<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  redirect<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  index<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  maxAge<span class="token operator">:</span> <span class="token number">2000</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>nest</code> 中 <code>max-age</code> 是以 <code>ms</code> 为单位的，也就是在 <code>2s</code> 后进行对比：<code>Last-Modified</code> &amp; <code>If-Modified-Since</code>。</p><p>开始看动画：</p><p><img src="https://to-out-use.oss-cn-hangzhou.aliyuncs.com/common/Kapture%202022-08-19%20at%2020.55.52.gif" alt="Kapture 2022-08-19 at 20.55.52.gif" loading="lazy"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec042328f299435abafd1a2ca0d163bf~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></p><p>可以看到，第一次请求是 <code>4.8MB</code>, 第二次是 <code>290B</code>（因为 <code>2</code> 秒很快，所以已经过了缓存，并且比对完了，此时的 <code>200</code> 等同于 <code>304</code> 效果），可以仔细观察下第5次，恰好命中了缓存，所以是 <code>disk cache</code>。</p><p><strong><code>Etag</code> &amp; <code>If-None-Match</code></strong></p><p>细心的同学可能已经发现个问题，根据修改时间去做对比很容易漏掉一种场景：<code>就是打开了文件又保存了一下，没做任何变更，但是此时，计算机已经给文件打上了最新的时间</code>。</p><p>这个时候，后面的这一对头就派上用场了。</p><hr><p>所谓：“年年岁岁花相似，岁岁年年人不同”。本质来讲这岁岁年年其实还是这个人，但是花可就不是了，时间也不是。</p><p>同理，<code>Etag</code> 是根据内容产生的 <code>hash</code> ，跟一个人的<code>基因序列</code>一样，除非<code>基因序列</code>变了，那这个人就变了，至于变成啥样子，咱也不知道。所以内容变了，<code>Etag</code> 也就变了。</p><p>跟上面的标签对是一样的，缓存前，本地记下原始的 <code>Etag</code>，等到缓存过期后，把原始的 <code>Etag</code> 赋给 <code>Request</code> 的 <code>If-None-Match</code> 头。带着这个头，去服务端对比。</p><p>静态服务器代码：</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript">app<span class="token punctuation">.</span><span class="token function">useStaticAssets</span><span class="token punctuation">(</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'..'</span><span class="token punctuation">,</span> <span class="token string">'public'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">setHeaders</span><span class="token operator">:</span> <span class="token punctuation">(</span>res<span class="token punctuation">,</span> path<span class="token punctuation">,</span> stat<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// res.setHeader(</span>    <span class="token comment">//   'Expires',</span>    <span class="token comment">//   dayjs('2022-08-20 13:00:15').add(15, 'seconds').toDate(),</span>    <span class="token comment">// );</span>    <span class="token comment">// res.setHeader('Cache-Control', 'private');</span>    <span class="token comment">// res.setHeader('Last-Modified', dayjs('2022-08-19 19:38:15').toDate());</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Date'</span><span class="token punctuation">,</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  lastModified<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token comment">// etag: false,</span>  redirect<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  index<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  maxAge<span class="token operator">:</span> <span class="token number">2000</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>继续看动画：</p><p><img src="https://to-out-use.oss-cn-hangzhou.aliyuncs.com/common/Kapture%202022-08-19%20at%2021.17.10.gif" alt="Kapture 2022-08-19 at 21.17.10.gif" loading="lazy"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94243716906e447e939142cbce763572~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></p><p>还是老对话了，客户端缓存过期了，浏览器带着原始 <code>Etag</code> (<code>If-None-Match</code>)去请求服务器，服务器发现 <code>Etag</code> 没变过，说：“浏览器，你可以继续用原来的缓存”，于是，客户端此时拿到的资源还是原来缓存里的。</p><h3 id="Result（结论）"><a href="#Result（结论）" class="headerlink" title="Result（结论）"></a>Result（结论）</h3><h4 id="HTTP-缓存体系"><a href="#HTTP-缓存体系" class="headerlink" title="HTTP 缓存体系"></a>HTTP 缓存体系</h4><p><strong>都看到这里了，剩下的总结就交给读者吧，这里只列举大纲，实际详细的内容上文已经有了。</strong></p><ul><li>存储策略</li><li>过期策略</li><li>对比策略</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://httpwg.org/specs/rfc7234.html#validation.received">Http 规范</a></li><li><a href="https://mp.weixin.qq.com/s/qOMO0LIdA47j3RjhbCWUEQ">彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">MDN</a></li></ul><hr><p>最后，本次文章的内容到这里就全部结束了，我是<code>不换</code>，浪子回头金不换的那个不换哟～，如果本文对你有所帮助，可以帮忙点个小赞，如果有不对的地方，可以评论帮我斧正。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精读《React技术揭秘》中 卷三</title>
      <link href="/precision-react-demystified2-3/"/>
      <url>/precision-react-demystified2-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>书籍传送门：<a href="https://react.iamkasong.com/">React技术揭秘</a>——卡颂</p><blockquote><p>前言：整篇文章，我都将以<code>问题</code>+<code>笔记</code>的形式作为精读的导语展开叙述～<strong>文末有彩蛋喔～～～</strong></p></blockquote><p>上一篇文章中，我们已经了解了<em>架构篇</em>的<code>Commit</code>阶段中的<code>mutation</code> 和 <code>before mutation</code> 阶段，这一节我们继续上一节，聊一下<code>Commit</code>阶段的 <code>layout</code>。</p><span id="more"></span><p>在聊之前，我们先来解答一下，上一节留下的问题：</p><blockquote><ol><li>一个组件中多个 <code>useEffect</code> 的执行顺序是固定的吗？</li></ol></blockquote><p>答：是固定的，一个组件内部的 <code>useEffect</code> 会形成一个环状的链表结构，所以会顺序执行。</p><blockquote><ol start="2"><li>一个组件中如果出现多个 <code>useEffect</code> 和 <code>useLayoutEffect</code>，执行顺序是怎样的？</li></ol></blockquote><p>答：先执行 <code>useLayoutEffect</code>，后执行 <code>useEffect</code>。</p><blockquote><ol start="3"><li>嵌套组件中的 <code>useEffect</code> 和 <code>useLayoutEffect</code> 的执行顺序又是怎样的？</li></ol></blockquote><p>答：嵌套组件中的  <code>useEffect</code> 和 <code>useLayoutEffect</code>，会按照最深的子组件，依次往上执行，按照 <code>render</code> 阶段形成的 <code>effectList</code>。 </p><p><strong>补充</strong></p><pre class="language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">const</span> <span class="token function-variable function">Test</span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>s<span class="token punctuation">,</span> setS<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">render </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>props<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> name <span class="token operator">=</span> props<span class="token punctuation">.</span>name    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">effect </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>props<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">effect cleanup </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> name <span class="token operator">=</span> props<span class="token punctuation">.</span>name    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">layout effect </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>props<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">layout cleanup </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setS</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">update </span><span class="token punctuation">&#123;</span>s<span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>b<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">Child</span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">render </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>props<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> name <span class="token operator">=</span> props<span class="token punctuation">.</span>name    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">effect </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>props<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">effect cleanup </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> name <span class="token operator">=</span> props<span class="token punctuation">.</span>name    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">layout effect </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>props<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">layout cleanup </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span><span class="token punctuation">&#125;</span></code></pre><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 观测执行顺序</span>render parentrender arender blayout cleanup alayout cleanup blayout cleanup parentlayout effect alayout effect blayout effect parenteffect cleanup aeffect aeffect cleanup beffect beffect cleanup parenteffect parent</code></pre><p><strong><code>layout</code>阶段，同样从以下时机阐述：</strong></p><p><code>layout</code> 阶段也是遍历 <code>effectList</code> ，并且执行 <code>commitLayoutEffects</code></p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">commitLayoutEffects</span><span class="token punctuation">(</span>root<span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> committedLanes<span class="token operator">:</span> Lanes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> effectTag <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>effectTag<span class="token punctuation">;</span>    <span class="token comment">// 调用生命周期钩子和hook</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Update <span class="token operator">|</span> Callback<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>      <span class="token function">commitLayoutEffectOnFiber</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">,</span> committedLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 赋值ref</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Ref<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">commitAttachRef</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>该函数大致做了两件事：</p><ul><li><code>commitLayoutEffectOnFiber</code>（ <strong>调用生命周期钩子</strong>和 <strong><code>hook</code></strong> 相关操作）</li><li><code>commitAttachRef</code>(赋值 <code>ref</code>)</li></ul><p><code>commitLayoutEffectOnFiber</code> 时，会针对两种类型的组件做不同的处理：</p><ul><li><code>classComponent</code><ul><li>会通过 <code>current === null</code> ?区分是 <code>mount</code> 还是 <code>update</code> ，调用 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 。</li><li>如果在 <code>this.setState</code> 中设置了 <code>callback</code>，也会在此时执行。</li></ul></li><li><code>FunctionComponent</code><ul><li>会调用 <code>useLayoutEffect hook</code> 的回调函数，调度 <code>useEffect</code> 的销毁与回调函数</li><li>对于 <code>HostRoot</code>，即<code>rootFiber</code>，如果赋值了第三个参数回调函数，也会在此时调用。</li></ul></li></ul><p><strong><code>commitAttachRef</code> 做的事则很简单，获取 <code>DOM</code> 实例，更新 <code>Ref</code></strong></p><p><strong>那么，思考一个问题，<code>componentDidMount</code> 或者 <code>useLayoutEffect</code> 中的 <code>ref</code> 存在<code>DOM</code>吗？</strong></p><p><strong><code>From StackOverflow</code>: <a href="https://stackoverflow.com/questions/44074747/componentdidmount-called-before-ref-callback">componentdidmount-called-before-ref-callback</a></strong></p><p><code>React 官网</code><a href="https://react.html.cn/docs/refs-and-the-dom.html">传送门</a> : </p><blockquote><p>React 将在组件挂载时将 DOM 元素传入ref 回调函数并调用，当卸载时传入 null 并调用它。在componentDidMout 和 componentDidUpdate 触发之前，Refs 保证是最新的。</p></blockquote><p>同步源码(<code>mutation</code>阶段)：</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">commitMutationEffects</span><span class="token punctuation">(</span>root<span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> renderPriorityLevel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 遍历effectList</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> effectTag <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>effectTag<span class="token punctuation">;</span>    <span class="token comment">// 根据 ContentReset effectTag重置文字节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> ContentReset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">commitResetTextContent</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新ref</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Ref<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">commitDetachRef</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 根据 effectTag 分别处理</span>    <span class="token keyword">const</span> primaryEffectTag <span class="token operator">=</span>      effectTag <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Placement <span class="token operator">|</span> Update <span class="token operator">|</span> Deletion <span class="token operator">|</span> Hydrating<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>primaryEffectTag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 插入DOM</span>      <span class="token keyword">case</span> Placement<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token function">commitPlacement</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>        nextEffect<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;=</span> <span class="token operator">~</span>Placement<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 插入DOM 并 更新DOM</span>      <span class="token keyword">case</span> PlacementAndUpdate<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 插入</span>        <span class="token function">commitPlacement</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>        nextEffect<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;=</span> <span class="token operator">~</span>Placement<span class="token punctuation">;</span>        <span class="token comment">// 更新</span>        <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>        <span class="token function">commitWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// SSR</span>      <span class="token keyword">case</span> Hydrating<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        nextEffect<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;=</span> <span class="token operator">~</span>Hydrating<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// SSR</span>      <span class="token keyword">case</span> HydratingAndUpdate<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        nextEffect<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;=</span> <span class="token operator">~</span>Hydrating<span class="token punctuation">;</span>        <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>        <span class="token function">commitWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 更新DOM</span>      <span class="token keyword">case</span> Update<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>        <span class="token function">commitWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 删除DOM</span>      <span class="token keyword">case</span> Deletion<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token function">commitDeletion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> nextEffect<span class="token punctuation">,</span> renderPriorityLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到，在 <code>mutation</code> 阶段就完成了 <code>Ref</code> 更新。</p><hr><ul><li><code>current Fiber</code> 树切换</li></ul><pre class="language-typescript" data-language="typescript"><code class="language-typescript">root<span class="token punctuation">.</span>current <span class="token operator">=</span> finishedWork<span class="token punctuation">;</span></code></pre><blockquote><p>在双缓存机制一节我们介绍过，<code>workInProgress Fiber</code> 树在 <code>commit</code> 阶段完成渲染后会变为 <code>current Fiber</code> 树。这行代码的作用就是切换 <code>fiberRootNode</code> 指向的 <code>current Fiber</code> 树。</p></blockquote><p><strong>那么这行代码为什么在这里呢？（在 <code>mutation</code> 阶段结束后，<code>layout</code> 阶段开始前。）</strong></p><p>如何回答这个问题呢？其实我觉得看一下 <code>React</code> 源码位置的这几段注释就可以了，<code>WIP</code> 树要 <code>layout</code>就必须在 <code>layout</code> 之前完成转换。<code>componentWillUnmount</code> 代表着一次组件的生命周期结束。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// The work-in-progress tree is now the current tree. This must come after</span>  <span class="token comment">// the mutation phase, so that the previous tree is still current during</span>   <span class="token comment">// componentWillUnmount, but before the layout phase, so that the finished</span>    <span class="token comment">// work is current during componentDidMount/Update.</span></code></pre><p>答： <code>componentWillUnmount</code> 会在 <code>mutation</code> 阶段执行。此时 <code>current Fiber</code> 树还指向前一次更新的 <code>Fiber</code> 树，在生命周期钩子内获取的 <code>DOM</code> 还是更新前的。</p><h3 id="文末彩蛋：手写笔记"><a href="#文末彩蛋：手写笔记" class="headerlink" title="文末彩蛋：手写笔记"></a>文末彩蛋：手写笔记</h3><p><img src="https://bigdreamerblog.oss-cn-beijing.aliyuncs.com/dev-blog/2022/06/React%E6%8F%AD%E7%A7%98-5.jpg" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精读《React技术揭秘》中 卷二</title>
      <link href="/precision-react-demystified2-2/"/>
      <url>/precision-react-demystified2-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>书籍传送门：<a href="https://react.iamkasong.com/">React技术揭秘</a>——卡颂</p><blockquote><p>前言：整篇文章，我都将以<code>问题</code>+<code>笔记</code>的形式作为精读的导语展开叙述～<strong>文末有彩蛋喔～～～</strong></p></blockquote><p>上一篇文章中，我们已经了解了<em>架构篇</em>的<code>Render</code>阶段，这一节我们继续上一节，聊一下<code>Commit</code>阶段。</p><span id="more"></span><p><code>Commit</code>阶段主要分为<code>before mutation</code>、<code>mutation</code>、<code>layout</code>三个阶段。</p><pre class="language-tsx" data-language="tsx"><code class="language-tsx"><span class="token function">commitRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上一章聊到<code>commitRoot</code>是<code>commit</code>工作的起点</p><p>下面就正式介绍 <code>commit</code>阶段的流程：</p><p><code>before mutation</code><br>    - <code>DOM</code>操作前</p><p><code>mutation</code><br>    - <code>DOM</code>操作中</p><p><code>layout</code><br>    - <code>DOM</code>操作完毕</p><hr><p>在介绍<code>before mutation</code>之前，先回忆一件事：</p><blockquote><p><code>V16</code>之后，给部分<code>componentWillxxx</code>打上了<code>UNSAFE_</code>标记，这个 <strong>xxx</strong>分别指的是：<code>componentWillMount</code>,<code>componentWillRecieveProps</code>、<code>componentWillUpdate</code>.</p></blockquote><p>为什么要加<code>UNSAFE_</code>呢？</p><ul><li>因为在<code>concurrent</code>模式下，<code>render</code>阶段会被多次打断重新开始，所以就会导致这些在<code>render</code>阶段执行的生命周期钩子，重复执行，导致数据不准或者死循环。</li></ul><p>其实，大家也有注意到，出现的新的<code>getDerivedStateFromProps</code>就是替换<code>componentWillRecieveProps</code>的，而<code>getSnapshotBeforeUpdate</code>则是替换<code>componentWillUpdate</code>.</p><p>至于更加详细的差别，可以参考卡老师的：<a href="https://juejin.cn/post/6847902224287285255#comment">深入源码剖析componentWillXXX为什么UNSAFE</a> : <a href="https://juejin.cn/post/6847902224287285255#comment">https://juejin.cn/post/6847902224287285255#comment</a></p><p>好了，现在开始进入这个阶段在做的三个步骤介绍：</p><ul><li><p>处理 <code>DOM</code> 节点渲染&#x2F;删除后的 <code>autoFocus</code>、<code>blur</code> 逻辑。</p></li><li><p>调用 <code>getSnapshotBeforeUpdate</code> 生命周期钩子。</p></li><li><p>调度 <code>useEffect</code>。</p></li></ul><p>我们着重关注下 <code>useEffect</code>，这里 <code>useEffect</code> 是异步的。</p><p>整个 <code>useEffect</code> 异步调用分为三步：</p><ul><li><code>before mutation</code> 阶段在 <code>scheduleCallback</code> 中调度 <code>flushPassiveEffects</code></li><li><code>layout</code> 阶段之后将 <code>effectList</code> 赋值给 <code>rootWithPendingPassiveEffects</code></li><li><code>scheduleCallback</code> 触发 <code>flushPassiveEffects</code>，<code>flushPassiveEffects</code> 内部遍历 <code>rootWithPendingPassiveEffects</code></li></ul><p>为什么 <code>useEffect</code> 是异步的呢？</p><blockquote><p>与 <code>componentDidMount</code> 、<code>componentDidUpdate</code> 不同的是，在浏览器完成布局与绘制之后，传给 <code>useEffect</code> 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p></blockquote><p><code>useEffect</code> 异步执行的原因主要是防止同步执行时阻塞浏览器渲染。</p><p>!!!预留两个疑问，下篇文章中统一解答，同样也是我自己的疑问：</p><blockquote><ol><li><p>一个组件中多个 <code>useEffect</code> 的执行顺序是固定的吗？</p></li><li><p>一个组件中如果出现多个 <code>useEffect</code> 和 <code>useLayoutEffect</code>，执行顺序是怎样的？</p></li><li><p>嵌套组件中的 <code>useEffect</code> 和 <code>useLayoutEffect</code> 的执行顺序又是怎样的？</p></li></ol></blockquote><hr><p>接下来，我们开始介绍 <code>mutation</code>阶段：</p><p>类似 <code>before mutation</code> 阶段，<code>mutation</code> 阶段也是遍历 <code>effectList</code>，执行函数。这里执行的是 <code>commitMutationEffects</code>。</p><ul><li>根据 <code>ContentReset effectTag</code> 重置文字节点</li><li>更新 <code>ref</code></li><li>根据 <code>effectTag</code> 分别处理，其中 <code>effectTag</code> 包括 <code>(Placement | Update | Deletion | Hydrating)</code></li></ul><p><strong><code>Placement effect</code></strong></p><p><em><code>Fiber</code> 节点对应的 <code>DOM</code> 节点需要插入到页面中</em></p><ul><li>获取父级 <code>DOM</code> 节点。其中 <code>finishedWork</code> 为传入的 <code>Fiber</code> 节点。</li><li>获取 <code>Fiber</code> 节点的 <code>DOM</code> 兄弟节点</li><li>根据 <code>DOM</code> 兄弟节点是否存在决定调用 <code>parentNode.insertBefore</code> 或 <code>parentNode.appendChild</code> 执行 <code>DOM</code> 插入操作。</li></ul><p>值得注意的一点是：<code>Fiber</code> 结构并不会和 <code>DOM</code> 结构完全一致，所以递归 <code>Fiber</code> 去找 <code>DOM</code> 结构时，复杂度会提升，且是指数倍。</p><p><strong><code>Update effect</code></strong></p><ul><li><p>区分 <code>Host Component</code> 和 <code>Function Component</code></p><ul><li><code>Host Component</code> 中主要做了几件事<ul><li>处理 <code>style</code></li><li>处理 <code>DANGEROUSLY_SET_INNER_HTML</code></li><li>处理 <code>children</code></li><li>处理剩余 <code>props</code> (通常指的是原生 <code>dom</code> 节点的一些属性值 )</li></ul></li><li><code>Function Component</code> 中主要做了一件事<ul><li>调用 <code>useLayoutEffect</code> 的销毁函数</li></ul></li></ul></li></ul><p><strong><code>Deletion effect</code></strong></p><ul><li>递归调用 <code>Fiber</code> 节点及其子孙 <code>Fiber</code> 节点中 <code>fiber.tag</code> 为 <code>ClassComponent</code> 的 <code>componentWillUnmount</code> <code>(opens new window)</code> 生命周期钩子，从页面移除 <code>Fiber</code> 节点对应 <code>DOM</code> 节点</li><li>解绑 <code>ref</code></li><li>调度 <code>useEffect</code> 的销毁函数</li></ul><h3 id="文末彩蛋：手写笔记"><a href="#文末彩蛋：手写笔记" class="headerlink" title="文末彩蛋：手写笔记"></a>文末彩蛋：手写笔记</h3><p><img src="https://bigdreamerblog.oss-cn-beijing.aliyuncs.com/dev-blog/2022/06/React%E6%8F%AD%E7%A7%98-5.jpg" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精读《React技术揭秘》中 卷一</title>
      <link href="/precision-react-demystified2/"/>
      <url>/precision-react-demystified2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>书籍传送门：<a href="https://react.iamkasong.com/">React技术揭秘</a>——卡颂</p><blockquote><p>前言：整篇文章，我都将以<code>问题</code>+<code>笔记</code>的形式作为精读的导语展开叙述～<strong>文末有彩蛋喔～～～</strong></p></blockquote><p>上一篇文章中，我们已经了解了<code>fiber</code>架构，<code>fiber</code>思想以及<code>React fiber</code>的设计理念，本篇，我们着重了解<strong>架构篇</strong>：</p><span id="more"></span><h3 id="React-架构篇"><a href="#React-架构篇" class="headerlink" title="React 架构篇"></a>React 架构篇</h3><p>分为<code>Render</code>&amp;<code>Commit</code>两个阶段；</p><p><strong>Render 阶段做了什么事？</strong></p><p><code>Render</code>阶段可以简单描述为：先遍历—&gt;后递归。遍历<code>diff</code>、递归<code>build dom</code>；</p><p><code>Render</code>阶段细分为：<code>beginWork</code> &amp; <code>completeWork</code></p><ul><li><code>beginWork</code><ul><li>传入<code>当前 fiber</code>节点，创建子<code>fiber</code>节点<pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span>   current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>   workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>   renderLanes<span class="token operator">:</span> Lanes<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// ...省略函数体</span><span class="token punctuation">&#125;</span></code></pre></li><li><code>current</code>指的是<code>wip.alternate</code>,也就是当前组件上一次更新时的<code>fiber</code>节点;</li><li><code>workInProgress</code>指的是当前组件的<code>fiber</code>;</li><li><code>renderLanes</code>指的是<code>优先级</code>；</li></ul></li></ul><p>可以通过<code>current !== null</code>来区分是<code>mount</code>还是<code>update</code>，基于此，<code>beginWork</code>又可以分为两个阶段：<code>mount</code>&amp;<code>update</code>.</p><p><code>mount</code>阶段，会根据不同的<code>fiber.tag</code>创建不同的<code>fiber</code>节点。</p><p><code>update</code>阶段</p><ul><li>会根据<code>props</code>与<code>fiber.type</code>的比对决定是否要复用<code>fiber</code>节点</li><li>根据<code>renderLanes</code>判断优先级，配合<code>Schedule</code>去实现任务调度</li></ul><p>问题：如果不能复用，怎么办呢？</p><p>答：进入<code>diff</code>，交给<code>reconcile</code>去处理。</p><p><code>beginWork</code>结束后，就会进入<code>reconcileChildren</code>.也就是传说中的<code>diff算法</code></p><blockquote><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>值得一提的是，mountChildFibers 与 reconcileChildFibers 这两个方法的逻辑基本一致。唯一的区别是：reconcileChildFibers 会为生成的 Fiber 节点带上 effectTag 属性，而 mountChildFibers 不会。</p></blockquote><p>在<code>reconcileChildren</code>结束后，紧接着就是根据<code>diff</code>结果为<code>fiber</code>打上<code>effetTag</code>，例如：它是增、改、还是删等。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// DOM需要插入到页面中</span><span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b00000000000010</span><span class="token punctuation">;</span><span class="token comment">// DOM需要更新</span><span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                   */</span> <span class="token number">0b00000000000100</span><span class="token punctuation">;</span><span class="token comment">// DOM需要插入到页面中并更新</span><span class="token keyword">export</span> <span class="token keyword">const</span> PlacementAndUpdate <span class="token operator">=</span> <span class="token comment">/*       */</span> <span class="token number">0b00000000000110</span><span class="token punctuation">;</span><span class="token comment">// DOM需要删除</span><span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*                 */</span> <span class="token number">0b00000000001000</span><span class="token punctuation">;</span></code></pre><p><strong>小疑问：<code>mount</code>阶段也会打<code>Placement</code>tag，那么执行 插入操作会不会很低效？</strong></p><p>答：<code>mount</code>阶段确实会打<code>Placement</code> tag，但是是在<code>rootFiber</code>上打的。</p><ul><li><code>completeWork</code></li></ul><p>跟 <code>beginWork</code>一样，都是根据不同的<code>tag</code>去做不同的处理。</p><p><strong>update</strong></p><ul><li>处理事件相关的回调函数的注册</li><li>处理 <code>style prop</code></li><li>处理<code>DANGEROUSLY_SET_INNER_HTML prop</code></li><li>处理<code>children prop</code></li></ul><p><strong>mount</strong></p><p>删除的文字是<code>卡老师</code>原文中的，但是，我觉得只要没渲染到页面上，它就还是<code>Fiber</code>树～正好跟上缓存的概念相对应。</p><ul><li><del>为<code>Fiber</code>节点生成对应的<code>DOM</code>节点</del> 为<code>Current Fiber</code>[屏幕上显示的]节点生成对应的<code>WIP Fiber</code>[正在内存中构建的]节点。</li><li><del>将子孙<code>DOM</code>节点插入刚生成的<code>DOM</code>节点中</del> 将子孙<code>Fiber</code>节点插入刚生成的<code>Fiber</code>节点中。</li><li>与<code>update</code>相似的的处理<code>props</code></li></ul><h3 id="文末彩蛋：手写笔记"><a href="#文末彩蛋：手写笔记" class="headerlink" title="文末彩蛋：手写笔记"></a>文末彩蛋：手写笔记</h3><p><img src="https://bigdreamerblog.oss-cn-beijing.aliyuncs.com/dev-blog/2022/06/React%E6%8F%AD%E7%A7%98-4.jpg" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精读《React技术揭秘》上</title>
      <link href="/precision-react-demystified1/"/>
      <url>/precision-react-demystified1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>书籍传送门：<a href="https://react.iamkasong.com/">React技术揭秘</a>——卡颂</p><blockquote><p>前言：整篇文章，我都将以<code>问题</code>+<code>笔记</code>的形式作为精读的导语展开叙述～<strong>文末有彩蛋喔～～～</strong></p></blockquote><span id="more"></span><h3 id="React理念篇"><a href="#React理念篇" class="headerlink" title="React理念篇"></a>React理念篇</h3><blockquote><p>我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。</p></blockquote><p>众所周知的一个概念是：<strong>JS和GUI渲染是互斥的</strong>；</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'i:'</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">var</span> newNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      newNode<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">'book'</span><span class="token punctuation">;</span>      main<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><code>Demo</code>来源：<a href="http://static.kancloud.cn/xiak/quanduan/375582">JS引擎和GUI引擎是互斥的</a></p><hr><p><code>React</code>解决了什么问题，如何实现？</p><p>[1] <code>CPU</code>瓶颈：数据渲染量大，设备性能不足，容易掉帧，造成用户视觉卡顿；<br>[2] <code>IO</code>瓶颈：网络延迟给用户造成的视觉感知；</p><blockquote><p>答案：”时间切片”。—– 将同步的更新变成可中断的异步更新。</p></blockquote><p><strong>问题：</strong></p><ol><li>同步的更新是针对于谁而言？<ul><li><code>React 15</code>而言。</li></ul></li><li>异步的更新中断后去做了什么？做完之后又干了什么？<ul><li>更新中断后，把控制权交给主线程去<code>Update</code>，做完之后检测是否有空闲时间，再去接着执行上一次中断后的任务。<strong>中断过程是发生在内存中的，所以用户不会有任何感知</strong></li></ul></li><li>什么时候会中断？<ul><li>有高优先任务进入；</li><li>当前帧无剩余时间；</li></ul></li></ol><h3 id="React-架构篇"><a href="#React-架构篇" class="headerlink" title="React 架构篇"></a>React 架构篇</h3><blockquote><p>React 15 架构</p></blockquote><ul><li><code>Reconciler</code>协调器，负责变化的组件。</li><li><code>Renderer</code>渲染器，负责将变化的组件渲染到页面中。</li></ul><p><code>mountComponent</code>&amp;<code>updateComponent</code>时，都会递归组件。</p><p><strong>递归开始，中途无法中断，当层级很深时，递归更新时间超过了316ms，用户交互就会明显感觉卡顿</strong>；</p><p><em><code>React15</code>的<code>Reconciler</code>做了什么？</em></p><p><code>Reconciler</code>和<code>Renderer</code>交替执行，通过递归挂载<code>dom</code>树。</p><blockquote><p>React 16架构</p></blockquote><ul><li><code>Scheduler</code>(调度器)—调度高优任务进入<code>Reconciler</code>。<strong>核心应该是后边的 <code>lans</code></strong></li><li><code>Reconciler</code>(协调器)—-负责找出变化的组件，并<code>diff</code>生成新的<code>DOM</code>结构</li><li><code>Renderer</code>(渲染器)—-负责将变化渲染到页面上</li></ul><p><strong>整个<code>scheduler</code>和<code>reconciler</code>都是在内存中进行的，只有当所有组件都完成<code>Reconciler</code>的工作，才会统一交给<code>Renderer</code>的去处理。</strong></p><hr><p>笔者阅读此处曾有过疑问：【中断是何时开始的？中断的是<code>commit</code>截断还是<code>render</code>阶段？会中断<code>render</code>任务吗？】</p><p>其实答案已经在文章中了，此处只是略作记录～</p><hr><p><code>Reconciler</code>会为虚拟<code>DOM(fiber)</code>打标记（<code>增</code>、<code>删</code>、<code>改</code>、<code>hooks</code>等）；</p><p><code>Renderer</code>会根据虚拟<code>DOM</code>中的标记，对真实<code>DOM</code>进行操作（同步执行）；</p><h3 id="Fiber-架构"><a href="#Fiber-架构" class="headerlink" title="Fiber 架构"></a>Fiber 架构</h3><p>读到这里，笔者跟大家其实都有同一个疑问：<strong>什么是<code>Fiber</code>？</strong></p><ul><li>架构维度<ul><li><code>stack reconciler</code>（<code>React 15</code>） —-&gt; <code>fiber reconciler</code>（<code>React 16</code>）；</li></ul></li><li>数据结构维度<ul><li>每个<code>Fiber</code>都对应一个<code>React Element</code>，记录了组件的类型和<code>DOM</code>信息；</li></ul></li><li>工作单元维度<ul><li>动态的<code>WIP</code> <code>Fiber</code> 树，保留了<code>Fiber</code>的更新信息；（<code>WIP fiber</code> —&gt; <code>current fiber</code>）</li></ul></li></ul><p><strong>问题：</strong> 咋不叫<code>虚拟DOM</code>了，那现在叫啥？</p><p>原来的<code>虚拟DOM</code>已经更名为<code>Fiber DOM</code>，其实底层还是一样的思想，就是一个<code>JS对象</code>。描述<code>真实DOM</code>在内存中的形态。</p><h3 id="Fiber-工作原理"><a href="#Fiber-工作原理" class="headerlink" title="Fiber 工作原理"></a>Fiber 工作原理</h3><blockquote><p>双缓存技术：内存中构建并直接替换；</p></blockquote><p><strong>current fiber</strong> —–&gt; <strong>wip fiber</strong>，每次<code>update</code>始终会创建一个新的<code>wip fiber</code>，使用<code>alternate</code>指针指向<code>current fiber</code>。</p><p><strong>问题：</strong> 新的<code>wip fiber</code>是根据旧的<code>current fiber</code>去构建吗？</p><p>答：答案是肯定的，<code>wip fiber</code>会根据旧的<code>current fiber</code>去构建，复用其节点数据。</p><h3 id="深入理解JSX"><a href="#深入理解JSX" class="headerlink" title="深入理解JSX"></a>深入理解<code>JSX</code></h3><p>[1] 什么是<code>JSX</code>？</p><ul><li><code>JSX</code>是一种语法，用来描述当前组件内容的数据结构。</li></ul><p>[2] <code>JSX</code>与<code>Fiber</code>有什么关系？</p><ul><li><code>mount</code>和<code>update</code>，都会根据对应的<code>jsx</code>数据结构，生成对应的<code>fiber</code>节点，<code>fiber</code>也是一种数据结构。</li></ul><p>[3] <code>React Element</code>和<code>React Component</code>是什么关系？<br>参考：<a href="https://zhuanlan.zhihu.com/p/29711902">React 探秘 - React Component 和 Element（文末附彩蛋demo和源码）</a></p><ul><li>使用<code>React Component</code>来生成<code>React Element</code>，但是不一定返回的是一定是<code>React Element</code>，也有可能是<code>null</code>。<ul><li>当写<code>JSX</code>时，<code>babel</code>会自动转译<code>JSX</code>为<code>React Element</code>.</li><li><code>React Component</code>分为：<code>Class Component</code>&amp;<code>Function Component</code>;</li></ul></li></ul><h3 id="文末彩蛋：手写笔记"><a href="#文末彩蛋：手写笔记" class="headerlink" title="文末彩蛋：手写笔记"></a>文末彩蛋：手写笔记</h3><p><img src="https://bigdreamerblog.oss-cn-beijing.aliyuncs.com/dev-blog/2022/05/React-guess-2.jpg" loading="lazy"></p><p><img src="https://bigdreamerblog.oss-cn-beijing.aliyuncs.com/dev-blog/2022/05/React-guess-3.jpg" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Antd使用笔记（scrollToFirstError使用小记）</title>
      <link href="/antd-notebook-error-scroll/"/>
      <url>/antd-notebook-error-scroll/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><blockquote><p>需求背景：当表单域在页面的指定区域，且提交按钮在表单域外。触发滚动定位。</p></blockquote><p>本文章不再赘述整个问题解决的过程，只记录结果～</p><p><code>Antd</code> <code>Disscussion</code> <a href="https://github.com/ant-design/ant-design/discussions/35290">讨论地址</a>：<a href="https://github.com/ant-design/ant-design/discussions/35290">https://github.com/ant-design/ant-design/discussions/35290</a></p><p><a href="https://codesandbox.io/s/zhu-ce-xin-yong-hu-antd-4-20-1-forked-vcm1h4?file=/demo.js:0-8140">代码沙盒演示地址</a>：<a href="https://codesandbox.io/s/zhu-ce-xin-yong-hu-antd-4-20-1-forked-vcm1h4?file=/demo.js:0-8140">https://codesandbox.io/s/zhu-ce-xin-yong-hu-antd-4-20-1-forked-vcm1h4?file=/demo.js:0-8140</a></p><span id="more"></span><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> useState <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"antd/dist/antd.css"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"./index.css"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Checkbox<span class="token punctuation">,</span> Button<span class="token punctuation">,</span> Affix <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"antd"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token function-variable function">RegistrationForm</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>form<span class="token punctuation">]</span> <span class="token operator">=</span> Form<span class="token punctuation">.</span><span class="token function">useForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token function-variable function">onFinish</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">values</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Received values of form: "</span><span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token function-variable function">handleSubmit</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    form<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Form</span></span> <span class="token attr-name">form</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>form<span class="token punctuation">&#125;</span></span> <span class="token attr-name">onFinish</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>onFinish<span class="token punctuation">&#125;</span></span> <span class="token attr-name">scrollToFirstError</span><span class="token punctuation">></span></span><span class="token plain-text">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Form.Item</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>agreement<span class="token punctuation">"</span></span> <span class="token attr-name">valuePropName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checked<span class="token punctuation">"</span></span>          <span class="token attr-name">rules</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">[</span>            <span class="token punctuation">&#123;</span>              <span class="token function-variable function">validator</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">_<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token operator">=></span>                value                  <span class="token operator">?</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token operator">:</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Should accept agreement"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">]</span><span class="token punctuation">&#125;</span></span>          <span class="token spread"><span class="token punctuation">&#123;</span><span class="token operator">...</span>tailFormItemLayout<span class="token punctuation">&#125;</span></span>        <span class="token punctuation">></span></span><span class="token plain-text">          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Checkbox</span></span><span class="token punctuation">></span></span><span class="token plain-text">            I have read the </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">agreement</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token plain-text">          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Checkbox</span></span><span class="token punctuation">></span></span><span class="token plain-text">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Form.Item</span></span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Form</span></span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Affix</span></span> <span class="token attr-name">offsetBottom</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">background</span><span class="token operator">:</span> <span class="token string">"#fafafa"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Button</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>handleSubmit<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">            Register          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Button</span></span><span class="token punctuation">></span></span><span class="token plain-text">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Affix</span></span><span class="token punctuation">></span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RegistrationForm</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span></code></pre><p>简单来讲，这里赘述下，官方文档中所没有的另外一种方案：</p><blockquote><p>背景：提交按钮未内置进<code>Form</code>标签中～</p></blockquote><p>在外部提交事件中触发<code>form.submit()</code>事件</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">handleSubmit</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    form<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>收集表单数据使用<code>onFinish</code>事件：</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">onFinish</span> <span class="token operator">=</span> <span class="token punctuation">(</span>values<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Received values of form: "</span><span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>常规标准用法：<a href="https://ant.design/components/form-cn/#components-form-demo-register">官方文档地址</a>: <a href="https://ant.design/components/form-cn/#components-form-demo-register">https://ant.design/components/form-cn/#components-form-demo-register</a></p><blockquote><p>致谢：感谢<a href="https://github.com/afc163">afc163</a> (<code>antd</code> <code>maintainer</code>)给予的答案以及指导</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Antd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何解决 nexus 不允许重复提交的策略限制</title>
      <link href="/how-to-resolve-nexus-not-allow-resubmit/"/>
      <url>/how-to-resolve-nexus-not-allow-resubmit/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>monorepo</code>仓库管理，其实社区已经有很多成熟的方案出来了，总结一句话就是<code>All In One</code>。例如，多个包全部收纳到一个仓库里去做发布管理，一套配置，一套命令，完成<code>build</code>、<code>publish</code>等。</p><blockquote><p>参考：<a href="https://blog.pig1024.me/posts/617162ba1225572af327c123">monorepo road map</a></p></blockquote><p>今天着重讲一下在使用<code>lerna</code>包管理工具时，出现的问题。</p><span id="more"></span><blockquote><p>问题：当<code>lerna publish</code>无法使用时，<code>nexus</code>也不允许重复提交。</p></blockquote><p>先解释一下，什么是：”<code>nexus</code>也不允许重复提交”？<code>&gt;&gt;</code> <code>nexus</code>发包策略：1. 重复提交；2. 不允许重复提交。</p><h3 id="原始人思路"><a href="#原始人思路" class="headerlink" title="原始人思路"></a>原始人思路</h3><ol><li><code>npm view pkg version</code>;</li><li><code>diff local pkg version</code>;</li><li><code>collect different pkg list</code>;</li><li><code>publish pkg list</code>;</li></ol><blockquote><p>使用工具库：<a href="https://github.com/omichelsen/compare-versions">compare-versions</a></p></blockquote><h3 id="高级灵长类"><a href="#高级灵长类" class="headerlink" title="高级灵长类"></a>高级灵长类</h3><p>学习<code>lerna</code>的思路：</p><ol><li><code>fetch from integrity with local version</code>;</li><li><code>publish pkg at the same time</code>;</li></ol><blockquote><p>使用工具库: <a href="https://github.com/npm/pacote">pacote</a></p></blockquote><p>综合考量下来，第二种方案更为优雅，大批量包版本发布耗时最短。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>是疫情，也是一面镜子</title>
      <link href="/epidemic-is-mirror/"/>
      <url>/epidemic-is-mirror/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>在过去的一个月里，我一直保持着居家办公状态，至于原因，我想都知道的。人算不如天算，明日是福是祸，七分人定，三分天定。</p><span id="more"></span><p>正如标题所言，疫情，是疫情，也是一面镜子，这面镜子在审视着每一个人，每个人的性格、人性、情绪、行为举止，更审视着制度、法律……</p><p>依稀记得，被封闭的那一天是<code>2022年3月14日</code>，莫名奇妙的，<code>15号就解封了</code>，紧接着<code>15号中午</code>听到室友消息，说又给封上了。晚上下班后，急匆匆的跑进超市，看着狼藉一片的<code>永辉超市</code>，说实在的，我有那么一丝焦急、无措。我仿佛看到了<code>韩国</code>、<code>日本</code>，报道出来的新闻中，被哄抢一空的超市。虽然这个<code>永辉超市</code>还有很多东西。</p><p>“挂面、方便面、火腿、鸡蛋、泡菜…”，对了，还要喝茶呢。</p><p>“茶叶、一包够吗？”</p><p>“应该够了”。</p><p>我有些手忙脚乱，但是也努力让自己冷静下来，慢慢思考，需要什么东西，能撑几天。</p><p>……</p><p>封闭的前一个星期，所有人的状态都是<code>OK</code>的，大家时不时出来溜溜圈，钓钓鱼，也努力，尽量做到不聚集。</p><p>慢慢的，时间滴答滴答，日子在一天天过去着，但是情况却也一天天不容乐观。</p><p>就这样，我开始了我的第一个<code>2+12</code>，<code>2+12</code>、<code>2+12</code>……</p><p>再后来，<code>7+7</code>、<code>7+7</code>……</p><p>几乎接下来的日子里，都在重置计数，大家有的人比较焦躁，也常常听到在跟志愿者吵架，甚至有因为<code>生意</code>打架的。再后来 <strong>“足不出户”</strong> 。 再后来，社区出现了一个个的 <strong>“顶梁柱—团购团长”</strong> 。其实以我个人角度而言，这些<strong>团长</strong> 们似乎才是真正的”英雄”，当然，大白们也是，志愿者们也是，那些辛苦在一线的工作人员也是，不管是工作也好，情怀也罢，我认为这就是一种民族气节的展示，值得钦佩。</p><p>这个时期，总要有人站出来的，总要有人做出牺牲，这或许就是华夏延续已久的美德和担当，因为没有人会希望自己的生活、自己的环境变得一团糟糕，无论为人也好，为己也罢。</p><p><code>ZF</code>也在期间发了几次物资，虽然不多，但是心意在了，我个人觉得够了，很知足了，当然最关键的时候还是要靠自己自足。虽然团购的物资贵的离谱，从 <strong>40元一颗的大白菜</strong>到<strong>58一斤的小米辣</strong> ，真实又好笑，又觉得无奈，吃也不是，不吃也不是。坐在电脑桌前的我猛吸了一口烟。</p><p>“唔噗……”</p><p>“行情就这喽，有的吃就不错咯～”</p><p>莞尔一笑，至少我是这样安慰自己的。</p><p>不管怎么样，心态要好，虽然贵，但是饿不着自己，但是确实贵。因为运费就贵，没办法，要理解。</p><p>抛却这些疫情期间的个人心理，或许可以再思考思考别的事情，别的一些有意思有发人省醒的事。</p><p>有人散布谣言，有人哄抬物价，有人指责志愿者，也有人不惜生命也要逃离这样的环境……</p><p>这不仅仅反应的是，一些悲观的人，唯恐天下不乱；一些贪婪的人，乘机大赚一波；一些站在道德制高点，一副圣母的样子，以自我为中心，自我封神……总之，各种牛魔鬼怪，很多很多。</p><p>“任何时候，在数落别人的时候，先自我省醒，是否可以做好。知道和做到是有一道鸿沟的。”，经常看<strong>法外狂徒张三</strong>的语录，自然也记得那么几句咯，这不是鸡汤，这是血淋淋的现实。有很多次，我曾按耐住冲突不去回复别人，但是我总是在敲下键盘的那一刻，又快速的删除了聊天框的内容，我在警告自己：</p><p>“不，你不能那么做，你不是圣人，别人说什么，做什么，跟你无关。”</p><p>需要解释的是，这并非是一种事不关己高高挂起的心态，而更多的是一些无奈，无奈当下，无奈个体差异。</p><p>所以，是疫情，也是一面镜子，照清楚了别人的样子，也照清楚了自己的样子。</p><p>接下来的日子里，祈祷疫情快快离去，祈祷身边的人都乐观一点，祈祷所有人都健康、快乐。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
